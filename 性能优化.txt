一、App启动优化
	
	App启动分为冷启动、温启动、热启动。
	
	冷启动：是指APP在手机启动后第一次运行，或者APP进程被kill掉后再次启动，可见冷启动的必要条件是该APP进程不存在，
			这就意味着系统需要创建进程，APP需要初始化。
			
			
	温启动：App进程还存在，当时Activity可能因为内存不足被回收。这时候启动App不需要重新创建进程，但是Activity的
			onCrate还是需要重新执行的，也就是要重新进行初始化和布局解析绘制。场景类似打开淘宝逛了一圈然后切到微
			信去聊天去了，过了半小时再次回到淘宝。这时候淘宝的进程存在，但是Activity可能被回收，这时候只需要重新
			加载Activity即可。
			
			
	热启动：App进程还存在，并且Activity对象仍然存在内存中没有被回收。可以重复避免对象初始化，布局解析绘制。
			场景就类似你打开微信聊了一会天这时候出去看了下日历，然后再打开微信，微信这时候启动就属于热启动。
	

	App启动优化主要是针对冷启动来进行优化。冷启动从点击Launcher图标开始，最先开始通过Zygote进程来孵化APP应用进程，
	然后应用进程就会创建我们的应用程序对象Application, 启动主线程，然后创建我们的Activity对象，然后进行布局解析绘制视图到我们
	的屏幕。
	
	在这一过程中，当APP应用进程创建后，应用进程就会显示一个属于应用程序的空白窗口，这就是为什么冷启动会出现黑白屏的原因？
	而一旦App进程完成了第一个Activty的绘制，应用进程就会用Activity的布局替换已经展示的空白窗口。
	
	
	针对这种现象我们可以来对冷启动的应用程序来进行优化，优化点在哪里呢？
	
	1. 视觉体验优化  首先是针对应用进程创建后直到我们的Activity绘制完成这段时间的黑白屏进行优化，有两种做法可以实现
	
		（1）设置透明主题

				<style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar">

					..........

					<item name="android:windowIsTranslucent">true</item>
				</style>

				
			将这个空白页（黑白屏）设置成充满屏幕并且透明，这样的话就看不到黑白屏界面了，但是再点击Launcher图标的时候，会给
			用户有一种有延迟的效果，就是点击了图标后过一会才显示出来我们的Activity，这样体验不是太好。


		（2）设置背景图片主题

			(a) 把这个样式设置给启动的SplashActivity

			    	<style name="SplashTheme" parent="Theme.AppCompat.Light.NoActionBar">
        				<item name="android:windowBackground">@mipmap/bg_splash</item>
    				</style>

			(b)然后在SplashActivity的onCreate方法，把Activity设置回原来的主题

				protected void onCreate(Bundle savedInstanceState) {
        					//替换为原来的主题，在onCreate之前调用
        					setTheme(R.style.AppTheme);
       		 			super.onCreate(savedInstanceState);
    				}


			这样在启动时就通过给用户看一张图片或是广告来防止黑白屏的尴尬，这种效果会给用户一种
			秒开程序的体验，但是实际上并没有真正的加块我们应用程序的启动速度，指标不治本。
			
	
	2.代码逻辑优化	想要真正加快应用程序的启动速度，关键还在于逻辑代码的优化，这一块代码就存在于Application的onCreate()和Activity的onCreate()中，不要在这两个方法中做大量的初始化工作，
			还有一个就是xml文件的优化
	
	
				通过命令查看应用程序的启动时间： adb shell am start -W 包名/类名
	
				杀死进程执行命令
				am start -W com.hxd.oasynergytest/com.hxd.gobus.mvp.activity.SplashActivity 
				
				Starting: Intent { act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] cmp=com.hxd.oasynergytest/com.hxd.gobus.mvp.activity.SplashActivity }
				Status: ok
				Activity: com.hxd.oasynergytest/com.hxd.gobus.mvp.activity.LoginActivity
				ThisTime: 231
				TotalTime: 984
				WaitTime: 1012
				Complete
				
				ThisTime  : 最后一个 Activity 的启动耗时(例如从 SplashActivity -> LoginActivity , 只统计 LoginActivity 的启动耗时)
				
				TotalTime : 启动一连串的 Activity 总耗时(有几个Activity 就统计几个)
				
				WaitTime : 进程的创建时间 + TotalTime 
				
				
				我们可以通过Debug.startMethodTracing()和 Debug.stopMethodTracing() 来检测初始化第三方SDK的耗时时长，这里把文件写到了sd卡中，然后把文件拖进AS里面我们可以
				通过查看trace文件来分析初始化第三方SDK的耗时时长。然后找到里面比较耗时的操作，然后再进行优化
				
				public void onCreate() {
						super.onCreate();
						File file = new File(Environment.getExternalStorageDirectory(),"app_trace");
						Debug.startMethodTracing(file.getAbsolutePath());
						
						initThirdSdk();
						
						Debug.stopMethodTracing();
				}   
					
				针对我的项目的启动时间：
				
					优化之前：311482 微妙
					优化之后：3356 微妙
				   
				
				优化方式：
				
					1. 把第三方组件的初始化放在子线程中进行初始化，但是有些组件的初始化可能会报错，因为它内部可能会涉及到Handler操作，UI操作，异步操作等。
					    建议对放在子线程初始化的组件进行延时加载，这样就可以了解是否会对项目造成影响。
						
						new Thread(new Runnable() {
							@Override
							public void run() {
							
								//设置线程的优先级，不与主线程抢资源
								Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
								//子线程初始化第三方组件
								Thread.sleep(5000);//建议延迟初始化，可以发现是否影响其它功能，或者是崩溃！
							}
						}).start();
						
						
					2. 将必须放在主线程中初始化的组件并且这些组件不用立即初始化完成的操作也进行延迟加载。
					
							handler.postDelayed(new Runnable() {
								@Override
								public void run() {
									//延迟初始化组件
									init();
								}
							}, 3000);
				

					3. 对组件初始化进行懒加载操作，懒汉式单例模式保证懒加载，只不过第一次稍微会慢一点。
					
					
					
二、布局优化

	1. GPU CPU负责计算好要绘制图形的数据，然后把计算好的数据交给GPU，GPU负责对图形的数据进行渲染，负责栅格化操作，就是根据图形坐标进行像素填充操作，然后显示到手机屏幕上。
	
		在布局文件中我们写一个Button（Button里面含有位置信息），然后通过xml解析加载到内存中，然后cpu进行计算处理成多维的向量图形(也就是纹理)，然后将向量图形交给GPU进行像素填充，
		这一步就是栅格化操作，然后GPU绘制成图形
		
	2. 为什么会有卡顿？
		（1）60fps 在与手机的交互过程中，手机画面反馈当fps在60以下，人眼是能感觉出来的，所以当帧率低于60fps的情况下我们能感觉到画面有卡顿和延迟现象；
		
		（2）Android系统每隔16ms(1000ms/60fps = 16.66ms)发出VSync(垂直同步信号), 触发对UI的渲染，如果每次渲染都能够按照这样的情况就能达到60fps的流畅画面，
			为了能实现60fps,所以计算渲染的大多数操作都必须在16ms之内完成。如果这一帧的图像的计算操作能够在16ms内，那就绘制，如果大于16ms，就等待下一个信号
			继续进行计算，这样就会导致这一个16ms没有绘制图像（60帧就变成了59帧，造成丢帧），然后就到下下一个16ms, 或者更多时间才能绘制出图像。
			
		 (3)卡顿原理分析	如果这一帧画面的渲染时间超过16ms，垂直同步机制会让硬件等待GPU完成栅格化操作，这样的话就会让这一帧画面多停留16ms，甚至更多时间，
							这样就会造成有些图像没有进行绘制，这样就造成了用户看到的画面会有停顿
			 
			 
	3.优化点： 16ms的时间主要做的事情有两个：第一个是将UI对象转换为一系列多边形和纹理，第二个就是CPU传递数据到GPU。所以我们要减少UI对象的转换次数和上传数据到GPU的次数。
	
			   那么如何减少这两个部分的时间呢？	第一个就是GPU减少xml布局文件转换成UI对象的时间；第二个是GPU减少重复绘制的时间
			   
	4.优化：4.1 减少布局嵌套，把不必要的布局去掉
				通过Hierarchyviewer布局层次，但是在AS3.1后就被去掉了这个东西，现在使用Layout Inspector来代替，Tools -> Layout Inspector
				
				include、merge 、ViewStub这三个布局都是官方提供的用于布局优化的
				
				include	能够引入另外一个xml布局到当前布局中
				
							对于一些都需要的布局如Toolbar，我们可以通过include来进行引用,这样的好处是可以减少上传Toolbar的纹理到GPU的过程，
							如果每个布局文件都写了Toolbar，那么每个布局的Toolbar都是不同的对象，这样就会造成多次上传，如果通过include来引用，
							就只会上传一次Toolbar的布局，然后再GPU进行缓存，下次再用的时候直接从缓存中拿即可
				
				merge	减少布局层级,不会增加层级会被系统自动忽略 	
							如果xml的根部局是FrameLayout, 直接替换成merge就能减少一个布局深度，因为DecorView本身就是一个FrameLayout。
							
				ViewStub	ViewStub是一个不可见，不用占用资源，只有设置viewstub为visible、invisible或者调用其inflater()方法时，其对应的布局文件才会被初始化。
							局限是viewstub的引用对象需要是一个布局layout文件，如果要是单个的view的话，viewstub就不合适了
								
	
			4.2 减少过度绘制，在开发者选项里有显示过度绘制区域选项，一共有4层：
					紫色：绘制一层
					绿色：绘制两层
					浅红：绘制三层
					深红：绘制四层
					
				如果我们看到我们的布局都是一堆红红的，那就是过度绘制了
				
				过度绘制的情况：
					（1）自定义控件中，onDraw()做了太多的重复绘制。
					
							控制好代码逻辑，尽量让用户看不到的区域不要进行绘制，比如重叠卡片，我们就可以对看不到的卡片区域进行不绘制，
							可以通过clipRect来实现画布裁剪，canvas.clipRect(0, 0, 200, 200)，指定(0,0)到(200,200)的矩形区域为绘制区域，
							而且还要为下一次绘制操作做准备，retore()恢复画布成原来的
					
					（2）布局层次太多，重叠性太强，GPU在用户看不到的区域也会进行渲染，导致耗时增加
					
							我们可以在项目需求的前提下，减少UI背景的绘制次数，从background属性着手。
							
			在平时编码的时候注意布局的编写，达到优化的效果，最后我们还可以通过Lint来检测布局，Analyze -> Inspect Code   按照Lint的提示修改布局即可。
			
	
三、内存泄漏

	1. java虚拟机
			sun公司指定的java虚拟机规范中，把java虚拟机分为 线程私有 和 共享数据区 两大部分。

		1.1 线程私有
		
			（1）PC 程序计数器  
			
					内存空间小，线程私有。字节码解释器工作是就是通过改变这个计数器的值来选取下一条需要执行指令的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖计数器完成
					
					如果线程正在执行一个 Java 方法	这个计数器记录的是正在执行的虚拟机字节码指令的地址
						
					如果正在执行的是 Native 方法	这个计数器的值则为 (Undefined)
					
					这个内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemory 情况的区域。
			
			（2）虚拟机栈	
			
					线程私有，生命周期和线程一致。描述的是 Java 方法执行的内存模型：每个方法在执行时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。
					每一个方法从调用直到执行结束，就对应着一个栈帧从虚拟机栈中入栈到出栈的过程。
					
					局部变量表：存放了编译期可知的各种基本类型(boolean、byte、char、short、int、float、long、double)、对象引用(reference 类型)和 return Address 类型(指向了一条字节码指令的地址)
					
					这个内存区域定义了两个异常：
					
					StackOverflow		线程请求的栈深度大于虚拟机所允许的深度
					
					OutOfMemory		如果虚拟机栈可以动态扩展，而扩展时无法申请到足够的内存。
		
			（3）本地方法栈	
	
					区别于 虚拟机栈的是，虚拟机栈为虚拟机执行 Java 方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。
					
					这个内存区域也会有 StackOverflowError 和 OutOfMemoryError 异常
					
					在有些jvm的实现当中，比如sun公司的hotspot虚拟机，它将虚拟机栈和本地方法栈合二为一了
					
		1.2 共享数据区

			（1）方法区
			
				主要存放的是:
					
					ClassLoader加载进来的是Class信息
					
					常量
					
					静态变量
					
					即时编译器编译后的代码信息
					
					一些特殊的Class对象
				
				
				运行时常量池
				
					方法区里面还有一部分是 运行时常量池	存放编译期生成的各种字面量和符号引用
				
					字面量  	String类型常量	八种基本类型的值	final常量
					
					符号引用	类/接口全名  字段名  方法名
					
					内存有限，无法申请时抛出 OutOfMemoryError。
					
			（2）java堆	
					
					java虚拟机管理的最大的内存，也是GC的主战场，主要存放对象实例和数组，里面定义了OOM异常
					
					
					
	2. GC如何确定一个对象能否被回收?				
					
					
		2.1 引用计数算法	在垃圾回收器的早期策略是使用的 引用计数算法 来判断一个对象是否存活

				A a = new A();		a的引用计数 		= 1
				B b = new B();		b的引用计数			= 1
					
				a.bb = b;			a的引用计数 +1 		= 2
				b.aa = a;			b的引用计数 +1 		= 2
				
				a = null;
				b = null;
				
				现在a和b互相引用，现在即使 a = null; b = null; 但是A类对象仍然被B类对象中的字段引用着，B类的对象也仍然被A类对象中的字段引用着
				尽管现在A类和B类对象都已经访问不到了，但是引用计数却都不为0，所以都不会a和b都不会被回收
				
				
		2.2 可达性分析算法（主流算法）			
					
				通过一系列的被称为“gc roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到“gc roots”没有任何引用链相连时，
				则证明此对象是不可用的，可以被回收。	
				
				GC ROOTS				
					|
					|
				 Object1						Object5
				  /	 \							 /	\	
				 /	  \						    /    \
			Object2  Object3				Object6  Object7
			   |	
			   |
			Object4 

				Object1，Object2，Object3，Object4	对象仍然存活，不能被回收
				
				Object5，Object6，Object7			可以被回收
			
				
				如果我们的对象经过第一次可达性分析算法发现跟gc roots没有引用链，就证明这个对象可以被回收，但是gc不会立即回收，java中还有一个自救的方法 finalize()。
				
				
				@Override
				protected void finalize() throws Throwable {
					super.finalize();
					//自救操作
					a = this;
				}  

				如果gc第2次可达性分析算法发现这个对象还是没有到gc roots的引用链，就会直接回收这个对象。finalize()只会对第一次扫描的对象进行死缓，提供自救。
				如果gc第2次可达性分析算法发现这个对象有到gc roots的引用链，就不会被回收
			
				
			可以作为“gc roots”的对象

					（1）虚拟机栈（栈帧中的局部变量表）中引用的对象

					（2）方法区中类静态属性引用的对象。

					（3）方法区中常量引用的对象

					（4）本地方法栈中JNI引用的对象
					
					
		2.3 引用 
			
			java中有四种引用 强，软，弱，虚
			
			强引用
			
				Object obj = new Object();		obj是指向Object对象的一个强引用
			
				如果一个对象拥有强引用，就算系统进行gc，强引用对象也不会被回收，即时爆出OOM该对象也不会被回收
			
			软引用	SoftReference
			
				Object obj = new Object();
				SoftReference softObj = new SoftReference<Object>(obj);
				
			
				内存足够时，软引用对象不会被回收，只有在内存不足时，系统才会回收软引用对象，通常用于实现缓存
				
			弱引用	WeakReference
			
			    Object obj = new Object();
				WeakReference<Object> weakObj = new WeakReference<>(obj3);
				
				只要系统进行gc，弱引用对象就一定会被回收
				
			虚引用	PhantomReference
			
				如果一个对象持有虚引用，那么这个对象随时可能被回收，甚至不能通过get方法来获得其指向的对象。
				虚引用唯一的作用是，当其指向的对象被回收后，自己被加入到引用队列，用做记录该引用指向的对象已被销毁。

				
			引用队列：从下面例子可以看出，被回收的对象都会被加入到引用队列中	
			
				
			//引用队列	
			ReferenceQueue<Object> referenceQueue = new ReferenceQueue<>();

			//软引用
			Object obj2 = new Object();
			SoftReference<Object> softObj = new SoftReference<>(obj2, referenceQueue);

			System.out.println("gc之前 soft ：" + softObj.get());
			System.out.println("gc之前 soft queue：" + referenceQueue.poll());

			obj2 = null;
			System.gc();
			Thread.sleep(1000);

			System.out.println("gc之后 soft：" + softObj.get());
			System.out.println("gc之后 soft queue：" + referenceQueue.poll());

			//弱引用
			Object obj3 = new Object();
			WeakReference<Object> weakObj = new WeakReference<>(obj3, referenceQueue);

			System.out.println("gc之前 weak：" + weakObj.get());
			System.out.println("gc之前 weak queue：" + referenceQueue.poll());

			obj3 = null;
			System.gc();
			Thread.sleep(1000);

			System.out.println("gc之后 weak：" + weakObj.get());
			System.out.println("gc之后 weak queue：" + referenceQueue.poll());

			//虚引用
			Object obj4 = new Object();
			PhantomReference<Object> plantomObj = new PhantomReference<>(obj4, referenceQueue);

			System.out.println("gc之前 plantom：" + plantomObj.get());
			System.out.println("gc之前 plantom queue：" + referenceQueue.poll());

			obj4 = null;
			System.gc();
			Thread.sleep(1000);

			System.out.println("gc之后 plantom：" + plantomObj.get());
			System.out.println("gc之后 plantom queue：" + referenceQueue.poll());

			
			gc之前 soft ：java.lang.Object@759ebb3d
			gc之前 soft queue：null
			gc之后 soft：java.lang.Object@759ebb3d
			gc之后 soft queue：null
			gc之前 weak：java.lang.Object@484b61fc
			gc之前 weak queue：null
			gc之后 weak：null
			gc之后 weak queue：java.lang.ref.WeakReference@45fe3ee3
			gc之前 plantom：null
			gc之前 plantom queue：null
			gc之后 plantom：null
			gc之后 plantom queue：java.lang.ref.PhantomReference@4cdf35a9
		
			在Android应用的开发中，为了防止内存溢出，在处理一些占用内存大而且生命周期较长的对象时候，可以尽量应用软引用和弱引用技术。
			对于软引用和弱引用的选择，如果只是想避免OutOfMemory异常的发生，则可以使用软引用。如果对于应用的性能更在意，想尽快回收一些占用内存比较大的对象，则可以使用弱引用。
			另外可以根据对象是否经常使用来判断选择软引用还是弱引用。如果该对象可能会经常使用的，就尽量用软引用。如果该对象不被使用的可能性更大些，就可以用弱引用。

			
	3.内存泄漏
			
		3.1 内存泄漏的根本原因
			
			堆内存中的长生命周期对象持有短生命周期对象的引用，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收。
			
			总结一句话就是不需要了该回收因为引用问题导致不能回收。内存泄漏会导致可用内存慢慢变少，让程序慢慢变卡。最终还会导致oom 内存溢出。
		
		3.2 应该怎么排查内存泄漏问题？			

			在android中我们执行一段代码，比如进入了一个新的页面(Activity)，这时候我们的内存使用肯定比在前一个页面大，而在界面finish返回后，
			如果内存没有回落，那么很有可能就是出现了内存泄漏。

			我们可以通过AS的Memory Profile或者DDMS中的heap观察内存使用情况。从内存监控工具中观察内存曲线，是否存在不断上升的趋势且不会在程序返回时明显回落。
			这种方式可以发现最基本，也是最明显的内存泄露问题，对用户价值最大，操作难度小，性价比极高。	

		3.3 造成内存泄漏的常见情况
		
			（1）集合中的对象未清理造成的内存泄露
			
				如果一个对象放入到ArrayList、HashMap等集合中，这个集合就会持有该对象的引用。当我们不再需要这个对象时，也并没有将它从集合中移除，
				这样只要集合还在使用（而此对象已经无用了），这个对象就造成了内存泄露。并且如果集合被静态引用的话，集合里面那些没有用的对象更会
				造成内存泄露了。所以在使用集合时要及时将不用的对象从集合remove，或者clear集合，以避免造成对象的内存无法被回收,从而造成内存泄漏。

            （1）静态变量造成的内存泄漏

                比如：静态的context，静态的view等；

                泄漏原因：静态变量存储在方法区，它的生命周期从类加载开始，到整个进程结束，一旦静态变量初始化后，它所持有的引用只有等到进程结束才会释放。

                解决办法：在适当的时候将静态变量置为null，使静态变量不再持有Activity的引用，这样Activity就可以被回收，从而避免内存泄露

			（2）外部类含有非静态内部类的静态变量造成的内存泄漏

                泄漏原因：非静态内部类默认持有外部类的引用，外部类的静态变量对应的对象要等到程序结束后才会被回收，
                          所以导致外部类无法的内存无法被回收，从而导致外部类发生内存泄漏

                解决办法：将非静态内部类改为静态内部类。还有一种就是将非静态内部类的提取出来成为一个外部类，然后将获取实例方法改成单例模式。

            （3）匿名内部类中有延迟任务，耗时操作造成的内存泄漏

                比如：Thread耗时，TimerTask耗时，AsyncTask耗时，Handler延迟发送消息等。

                泄漏原因：匿名内部类默认持有外部类的引用，匿名内部类中有延迟任务，耗时操作等，这时候我们退出activity，匿名内部类不管我们退出
                          activity与否，会把执行完里面的方法，因为activity被匿名内部类的对象所引用，导致activity的内存无法被回收，从而导致了内存泄漏。

                解决办法: 将匿名内部类改为静态内部类，并且将内部类持有外部类activity的引用封装为弱引用，并且可以在适当的时候取消任务，清空任务队列等。


            （4）单例模式持有Activity或Service的引用造成的内存泄漏

                泄漏原因：单例模式需要使用Context，这时如果我们传递的Context是Activity或者是Service，一旦这两个组件销毁了，会因为单例对象持有Activity或者Service
                          的引用导致Activity或者Service的内存得不到释放，从而导致内存泄漏

                修改办法：使用和单例对象生命周期一样长的Application的Context。

            （5）广播、系统服务回调接口、观察者未取消注册监听或回调的造成的内存泄漏

                比如：广播、系统服务回调接口、观察则模式等

                泄漏原因： 以广播为例，Activity中动态注册的广播接收器，一般性写法都是此Activity中持有创建的广播接收器的对象引用，并指明广播接收器对应的接收广播类型（IntentFilter）。
                           Activity中调用registerReceiver(mBroadcastReceiver, intentFilter)方法进行广播接收器的注册。此时，通过Binder机制向AMS(Activity Manager Service)进行注册。
                           AMS会对应的记录Activity上下文、广播接收器以及对应的IntentFilter等内容，并形成类似于消息的发布-订阅存储模式与结构。
                           当对应的广播发出时，在定义的广播接收器的onReceive(context, intent)方法回调中，对于Activity中动态注册的广播接收器，
                           onReceive方法回调中的context指的是Activity Context！也就是说，Activity与mBroadcastReceiver此时实际上是通过AMS相互持有强引用的。
                           因此，对于Activity中动态注册的广播接收器，一定要在对应的声明周期回调方法中去unregisterReceiver，以斩断此关联。
                           否则，就会出现当前Activity的内存泄露。

                解决办法：在activity销毁的时候进行反注册。

            （6）使用Activity或者Service的context.getSystemService获取系统服务造成的内存泄漏

                泄漏原因：系统服务会持有一个Context实例，具体是Activity还是Application的Context取决于调用者。Activity通过ContextImpl提供的setOuterContext方法在ApplicationContext类中
                          设置mOuterContext(Activity继承了ApplicationContext)，系统服务在创建的时候就通过这个ContextImpl的mOuterContext传递给系统服务内部的Context，所以如果我们
                          传递的是通过Activity的Context来获取系统服务的话，这个mOuterContext就是当前Activity，所以系统服务就持有了Activity的引用，系统服务一直存在与进程中，所以即使
                          我们销毁了Activity，Activity的内存也不会被回收,从而造成了内存泄漏。

                解决办法：针对有泄漏的系统服务通过Application的Context去获取。但是有些系统服务系统内部已经处理过了，可直接使用Activity来获取.

                          如果服务和UI相关，则用Activity的Context  LAYOUT_INFLATER_SERVICE  WINDOW_SERVICE  SEARCH_SERVICE等

                          如果是类似ALARM_SERVICE,CONNECTIVITY_SERVICE建议选用Application的Context

                          如果出现出现了内存泄漏，排除问题，可以考虑使用Application的Context

            （7）资源连接未关闭或未正常释放造成的内存泄露

                比如：各种连接，如数据库连接、网络连接和IO流连接等。

                泄漏原因：在对数据库进行操作的过程中，首先需要建立与数据库的连接，当不再使用时，需要调用close方法来释放与数据库的连接。只有连接被关闭后，
                          垃圾回收器才会回收对应的对象。否则，如果在访问数据库的过程中不关闭连接，将会造成大量的对象无法被回收，从而引起内存泄漏。

                          IO流也是一样的，当读取发生异常的时候，就不会执行后面的关闭流操作，所以我们要在finally代码块进行关闭。

                修改办法：在适当的时候关闭连接。

            （8）属性动画(repeatCount为无限模式)线程优化

                泄漏原因：动画同样是一个耗时任务，比如在Activity中启动了属性动画（ObjectAnimator），但是在销毁的时候，没有调用cancel方法，虽然我们看不到动画了，
                          但是这个动画依然会不断地播放下去，动画引用所在的控件，所在的控件引用Activity，这就造成Activity无法正常释放。因此同样要在Activity销毁
                          的时候cancel掉属性动画，避免发生内存泄漏。

                修改方法：在适当的时候取消动画。

            （9）集合中的对象未清理造成内存泄露

                泄漏原因：如果一个对象放入到ArrayList、HashMap等集合中，这个集合就会持有该对象的引用。当我们不再需要这个对象时，也并没有将它从集合中移除，
                          这样只要集合还在使用（而此对象已经无用了），这个对象就造成了内存泄露。并且如果集合被静态引用的话，集合里面那些没有用的对象更会
                          造成内存泄露了。所以在使用集合时要及时将不用的对象从集合remove，或者clear集合，以避免内存泄漏。

                修改方法：在适当的时候清空集合。


            （10）WebView没正确销毁造成的内存泄漏

                泄漏原因：因为WebView在加载网页后会长期占用内存而不能被释放，因此我们在Activity销毁后要调用它的destroy()方法来销毁它以释放内存。
                          另外在查阅WebView内存泄露相关资料时看到这种情况：WebView下面的Callback持有Activity引用，造成Webview内存无法释放，即使
                          是调用了WebView.destroy()等方法都无法解决问题（Android5.1之后）。
                          一般情况下，我们的activity退出的时候，都会主动调用 WebView.destroy() 方法，经过分析，destroy()的执行时间在onDetachedFromWindow之前，
                          所以就会导致不能正常进行unregister()。

                解决办法：核心思路就是让onDetachedFromWindow先走，那么在主动调用之前destroy()，把webView从它的parent上面移除掉。


            还有其他的一些情况也会导致内存泄漏，综合上面几种常见的内存泄露出现原因来看，造成内存泄漏的最根本原因就是因为长生命周期对象持有短生命周期
            对象的引用，造成短生命周期对象的内存无法得到释放，这种现象就是内存泄漏，内存泄漏意味着内存空间一直被占用，所以如果泄漏的内存太多就会占用
            堆内存的空间，最终造成OOM。


    4.内存抖动

        4.1 垃圾回收算法

            （1）标记清除算法

                 首先标记出所有需要回收的对象，在标记完成后统一回收被标记过的对象。

                 缺点：标记清除算法不会对对象进行移动，就是不会移动对象在内存中的位置，所以直接回收不存活的对象，就可能会造成内存碎片。
                       当内存碎片比较多时，就会造成一些内存的浪费，比如我们要申请一块连续的内存，虽然内存空间还是充足的，但是可能因为
                       内存碎片的原因，就是没存空间没有那么大的连续的内存，导致申请不了，爆出OOM。所以这种算法会造成内存碎片从而造成浪费。

            （2）复制算法

                 它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，
                 然后再把已使用过的内存空间一次清理掉。这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，
                 只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。

                 缺点：这种算法的代价是将内存缩小为原来的一半，持续复制长生存期的对象则导致效率降低。复制收集算法在对象存活率较高时就要
                       执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用
                       的内存中所有对象都100%存活的极端情况。

            （3）标记压缩算法

                 标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接
                 清理掉端边界以外的内存。

                 缺点：标记-压缩算法虽然缓解的内存碎片问题，但是它也引用了额外的开销，比如说额外的空间来保存迁移地址，需要遍历多次堆内存等。

        4.2 分代收集

            当前商业虚拟机的垃圾收集都采用分代收集算法。分代的垃圾回收策略，是基于不同的对象的生命周期是不一样的。因此，不同生命周期的
            对象可以采取不同的收集方式，以便提高回收效率。

            在Java程序运行的过程中，会产生大量的对象，因每个对象所能承担的职责不同所具有的功能不同所以也有着不一样的生命周期，有的对象
            生命周期较长，比如Android中的Application、启动的Service等；有的对象生命周期较短，比如一些函数内部new出来的String对象。

            在不进行对象存活时间区分的情况下，每次垃圾回收都是对整个堆空间进行回收，那么消耗的时间相对会很长，而且对于存活时间较长的对象
            进行的扫描工作等都是徒劳。因此就需要引入分治的思想，所谓分治的思想就是因地制宜，将对象进行代的划分，把不同生命周期的对象放在
            不同的代上使用不同的垃圾回收方式。

            现在主流的做法是将Java堆被分为新生代和老年代；新生代又被进一步划分为Eden和Survivor区， Survivor由From Space和To Space组成。
            这样划分的好处是为了更快的回收内存，根据不同的分代执行不同的回收算法；

            新生代: 新建的对象都是用新生代分配内存，当Eden满时，会把存活的对象转移到两个Survivor中的一个，当一个Survivor满了的时候会把
                    不满足晋升的对象复制到另一个Survivor。晋升的意思是对象每经历一次Minor GC (新生代中的gc)，年龄+1，年龄达到设置的一个阀
                    值后，被放入老年代。两个Survivor的目的是避免碎片。如果只有一个Survivor，那Survivor被执行一次gc之后，可能对象是A+B+C。
                    经历一次GC后B被回收。则会A| |C，中间少了B，造成碎片

            老年代：用于存放新生代中经过N次垃圾回收仍然存活的对象。老年代的垃圾回收称为Major GC。整堆包括新生代与老年代的垃圾回收称之为Full GC。

            永久代：主要存放所有已加载的类信息，方法信息，常量池等等。并不等同于方法区，只不过是主流的日公司的Hotspot JVM用永久代来实现方法区而已，
                    有些虚拟机没有永久代而用其他机制来实现方法区。这个区域存放的内容与垃圾回收要回收的Java对象关系并不大。

            一般来说，在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，所以一般选用复制算法，只需要付出少量存活对象的复制成本就
            可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。


        4.3 垃圾收集器
             垃圾收集算法是内存回收的概念，那么垃圾收集器就是内存回收的具体实现。Java虚拟机规范对如何实现垃圾收集器没有任何规定，所以不同的厂商、
             不同版本的虚拟机提供的垃圾收集器可能会有很大差别。

             Serial串行收集器、ParNew 收集器、Parallel Scavenge收集器、Serial Old收集器、Parallel Old收集器、CMS 收集器、G1收集器。

             android默认的垃圾收集器是 CMS 收集器。

        4.4 内存抖动的根本原因

            内存频繁的分配和回收，而频繁的gc会导致卡顿，严重时和内存泄漏一样可能会导致OOM。

        4.6 对于内存抖动，我们要注意？

           （1）尽量避免在循环体或者频繁调用的函数内创建对象，应该把对象创建移到循环体外

           （2）String拼接创建大量小的字符串对象造成的内存抖动，如频繁的日志拼接打印。


三、图片压缩和Bitmap内存管理

    1. 图片压缩有两种方式： 文件压缩、 内存压缩。

    2. 文件压缩方式：质量压缩、尺寸压缩、格式选择、哈夫曼编码的压缩方式。

        2.1 质量压缩

            原理：通过改变图片的位深和透明度来减少图片所占用的磁盘空间大小，所以不适合作缩略图。

            适用场景：适用于想保持图片质量的同时减小图片所占用的磁盘空间大小。

            总结: 质量压缩仅仅只是改变图片所占用的磁盘空间大小，并不会改变图片在内存中所占的大小，因为质量压缩不会改变图片的
                     分辨率，而Bitmap所占内存大小是通过分辨率和所占字节数决定的，所以宽高没变，所占的内存大小就不会改变。

            注意: 对于png的图片来说，由于png格式的图片是无损压缩,所以设置quality无效。


        2.2 尺寸压缩

            原理: 通过改变图片的分辨率(像素)来改变图片所占磁盘空间大小和内存大小。

            适用场景: 适用于作缓存缩略图片。

            总结: 尺寸压缩即修改图片宽高，所以会改变图片在内存中所占的大小。会影响图片质量。

        2.3 格式选择

            Android目前常用的图片格式有 png、jpeg、webp。

            png：无损压缩图片格式，支持Alpha通道，Android切图素材多采用此格式。

            jpeg：有损压缩图片格式，不支持背景透明，适用于照片等色彩丰富的大图压缩，不适合logo。

            webp：是一种同时提供了有损压缩和无损压缩的图片格式，派生自视频编码格式VP8，从谷歌官网来看，无损webp平均比png小26%，
                  有损的webp平均比jpeg小25%~34%，无损webp支持Alpha通道，有损webp在一定的条件下同样支持，有损webp在Android4.0
                  （API 14）之后支持，无损和透明在Android4.3（API18）之后支持。

            采用webp能够在保持图片清晰度的情况下，可以有效减小图片所占有的磁盘空间大小

        2.4 哈夫曼编码图片压缩（jpeg引擎库压缩）

            哈夫曼编码: 一种字符编码方式，常用于数据文件压缩。压缩率通常在20%—90%。

            主要思想：采取可变长编码方式，对文件中出现次数多的字符采取比较短的编码，对于出现次数少的字符采取比较长的编码，
                      可以有效地减小总的编码长度。

            libjpeg-turbo: C语言编写的jpeg编解码库。 https://libjpeg-turbo.org/

            编译文档: https://github.com/libjpeg-turbo/libjpeg-turbo/blob/master/BUILDING.md

            编译步骤:
                （1）生成configure(只需执行一次)
            	    如果生成x86架构的库需要NASM/YASM工具(armeabi不需要)
            	    sudo apt-get install libtool
            	    autoreconf -ivf

                （2）根据BUILDING.md 编写并执行脚本build.sh

            使用: 参考 build.sh中的 --prefix 配置的目录下的share/doc/libjpeg-turbo/example.c 中的write_JPEG_file函数

            使用步骤:
                （1）获得待压缩Bitmap

                （2）获得Bitmap中像素数据(ARGB->BGR)

                （3）libjpeg压缩

                    创建jpeg压缩对象

                    指定存储文件

                    设置压缩参数

                    开始压缩

                    循环写入每一行数据

                    压缩完成

                    释放jpeg对象

    3. 内存压缩

        3.1 Bitmap在加载时内存大小计算

            Bitmap.Config.ARGB_8888：即argb各占8位，总共32位，1个字节8位，即4个字节

                memorySize = width * height * 4

            Bitmap.Config.RGB_565：没有alpha通道，r占5位，g占6位，b占5位，总共16位，即2个字节

                memorySize = width * height * 2


            getAllocationByteCount()和getByteCount()的区别

            getByteCount()           是bitmap实际占的内存。

            getAllocationByteCount() 考虑到内存的复用，如果B复用了A的内存，返回的内存大小就是A的内存大小。

        3.2 内存压缩(采样率压缩)

            为什么叫采样率压缩？

                我们通过控制解码图片参数BitmapFactory.Options来控制解码出来的东西，通过设置options的参数inJustDecodeBounds
                来控制解码出来的图片信息，inJustDecodeBounds设置为true,这时候图片并没有真正加载到内存当中,而只是解码出图片
                的一些边界信息，也就是outXXX参数。通过outXXX参数我们可以获取到图片的宽高，这个过程就是采样的过程。

            压缩过程

                得到图片的宽高后我们可以动态的对图片进行缩放，缩放系数(采样率)就是通过宽高等信息来进行计算，然后通过设置
                inSampleSize参数来设置采样率，然后inJustDecodeBounds设置为false，表示解码出图片的所有信息，然后通过设置
                options参数来加载压缩后的图片。

            BitmapFactory.Options（控制解码图片参数）的一些常用参数

                inDensity           表示这个bitmap的像素密度，根据drawable目录

                inTargetDensity     表示要被画出来时到目标(屏幕)的像素密度

                inJustDecodeBounds  控制解码图片的边界信息 读取图片out…系列参数,如outWidth与outHeight，可用于计算内存大小

                inPreferredConfig   设置图片解码后的像素格式,如ARGB_8888/RGB_565

                inSampleSize        设置图片解码缩放比,如值为4，则加载图片宽高是原图的1/4,内存大小则是1/16

                inMutable           异变

                inBitmap            图片复用

            总结

                对于内存的降低，无论是选择jpg还是png更或者是webp。其实都是毫无意义的。Jpg是属于有损压缩，我们看见的jpg比png文件小，
                那是因为压缩率高。这都是属于文件存储范畴。对于内存来说，我们加载一张不带alpha通道使用RGB_565格式的png与一张jpg占用
                的内存大小都是一样的。对于内存的压缩我们能做的就是缩小图片尺寸与改变像素格式。


            图片缓存    内存缓存 + 磁盘缓存实现基本的图片缓存

                LruCache

                    android提供的一个缓存工具类，使用LRU缓存淘汰算法。根据数据的历史访问记录来进行淘汰数据，“如果数据最近被访问过，
                    那么将来被访问的几率也更高”。

                Lru算法基本原理

                    内部实现通过LinkedHashMap来实现，LinkedHashMap具体实现请研究数据结构。

                    (1)新数据插入到链表头部

                    (2)每当缓存命中（即缓存数据被访问），则将数据移到链表头部

                    (3)当链表满的时候，将链表尾部的数据丢弃

                内存缓存

                    内存缓存是通过LruCache来实现，里面有两个我们经常用到的方法

                    返回Bitmap所占用的内存大小
                        protected int sizeOf(String key, Bitmap value);

                    当Bitmap从LruCache中移除时回调，oldValue就是被移除的Bitmap
                        protected void entryRemoved(boolean evicted, String key, Bitmap oldValue, Bitmap newValue);

                磁盘缓存

                    DiskLruCache    用的是杰克沃顿大神写的，内部也是通过Lru算法来实现

                        https://github.com/JakeWharton/DiskLruCache


            图片内存复用

                图片内存复用就是在加载新图片的时候，可以使用之前以及加载过的图片的内存来作为新图片的内存，这样就不用再为新图片
                申请新的内存空间了。通过设置options.inBitmap参数来实现复用内存。

                但是复用内存有一些限制，可被复用内存的Bitmap必须具备以下条件才可被复用:

                    1. 可被复用的Bitmap必须设置inMutable为true（设置异变）

                    2. 4.4(API 19)之前

                            只有格式为jpg、png，并且待分配内存的Bitmap的宽高与被复用的Bitmap(从复用池中取出来的)的宽高必须一致，
                            并且inSampleSize为1的Bitmap才可被复用。并且被复用的Bitmap的inPreferredConfig会覆盖待分配内存的Bitmap
                            设置的inPreferredConfig；

                       4.4(API 19)之后

                            被复用的Bitmap的内存必须大于等于待分配内存的Bitmap的内存；


            Bitmap内存管理

                https://developer.android.google.cn/topic/performance/graphics/manage-memory.html


            通过列表显示1000张或者更多的图片，这就意味着要加载1000图片，我们改如何优化？

                分析

                    1.加载图片我们首先考虑到的肯定是内存开销，这么多张图片一起使用如果我们内存管理不当可能会造成OOM。
                      我们可以通过内存压缩和内存复用来减小内存压力。

                    2.而且这么多图片我们每次都从服务器上下载那肯定是不太好的，我们可以用缓存来进行优化。

                加载流程

                    每次加载图片我们首先从内存缓存中取，如果内存缓存没有，我们就从磁盘缓存中取，再从磁盘缓存中取之前，我们先从
                    复用池中查找时候是否有符合要求的图片，有的话我们就使用复用池图片的内存来加载新的图片，如果磁盘缓存中没有的话，
                    我们就从服务器上下载新的图片(从磁盘读取的)，在加载之前先压缩，然后还是从复用池中查找时候是否有符合要求的图片，
                    有的话我们就使用复用池图片的内存来加载新的图片(从服务器下载的)，然后把被复用内存的图片从复用池清除掉，没有的
                    话就是申请新的内存，然后把新图片放进内存缓存和磁盘缓存中，大概流程就是这样，这样就达到了一定的优化效果。

                具体实现

                    1.首先从网络上加载图片，在加载的时候我们对图片进行压缩，目的是为了减小图片内存大小，然后每加载一张图片，
                      我们就把刚加载的图片添加到内存缓存和磁盘缓存当中。这样我们下次取的时候就直接从缓存中取。

                    2.为了更一步减少内存，我们可以使用图片复用。我们创建一个Set集合也就是复用池，当Lru算法把Bitmap从LruCache
                      中移除的时候我们就可以把被移除的Bitmap的弱引用添加进复用池，为什么要使用弱引用，因为弱引用当GC扫过之后，
                      就会把这个Bitmap放进引用队列中，我们从引用队列中就可以找到被回收了的Bitmap。我们在加载新图片的时候就可以
                      从引用队列中取出可以被复用内存的Bitmap来实现图片内存复用。

    4. 巨图加载

        BitmapRegionDecoder 图片的局部解析

        内部主要方法

            //获取区域解码器对象   isShareable： 共享数据 false代表解码器会拷贝一份数据 这样即使is被关闭了 也不会造成影响
            public static BitmapRegionDecoder newInstance(InputStream is, boolean isShareable) throws IOException

            public static BitmapRegionDecoder newInstance(String pathName, boolean isShareable) throws IOException

            //根据Rect和Options来加载指定区域的Bitmap
            public Bitmap decodeRegion(Rect rect, BitmapFactory.Options options)

        巨图加载主要流程

            对我们来说巨图就是超大的图片，可能是横长图也可能是竖长图，就是非常宽和非常高的图片。这里我们针对竖长图来进行说明，
            竖长图指的就是图片高度是图片宽度几倍甚至十几倍的图片。这类图片如果我们直接加载进内存的话，由于图片分辨率过大加载
            进来的内存也比较大可能就会导致OOM，这是我们不想看到的，所以我们可以尝试加载指定区域的图片,并且通过Bitmap内存复用
            来复用上一次加载Bitmap的内存来减少内存压力。

            (1) 使用自定义View来作为加载长图的控件，根据图片源通过BitmapFactory.Options来解码出图片原始信息(宽高等)，然后设置
                Bitmap内存复用和格式来减少加载图片时的内存，并构建区域解码器对象用于解码指定区域的图片,然后调用requestLayout()
                来请求布局，这样就会走进测量流程。

            (2) 我们可以在onMeasure()方法中获取到View的宽高，然后通过Rect来指定要加载的图片区域，加载的图片宽可能比屏幕宽大，
                也可能比屏幕宽小，所以我们在加载图片区域的时候要以图片的宽度来进行加载，然后再把图片宽度缩放成和屏幕一样的宽
                度，这样图片就不会出现看不完图片的宽度和图片宽度只占屏幕一部分的情况，缩放因子就是视图宽/图片宽。然后一次要加
                载的图片高度就是视图高/加载因子。因为原图片高度太大，一次性加载不完，所以要按区域来加载。

            (3) 绘制确定区域的图片，在绘制的时候要复用上一次加载确定区域的图片内存，然后通过矩阵来进行宽高的缩放，然后把缩放后
                的图片绘制到屏幕上，这样我们就能看到加载确定区域的图片了。但是竖长图还有很多部分没有加载，这时候我们就可以通过
                手势滑动和触摸来确定接下来要加载的图片区域。

            (4) 通过手势GestureDetector和滑动帮助类Scroller来进行滑动，并且要设置View的触摸事件，然后把屏幕的触摸事件交给手势来
                进行处理，然后处理手势的事件即可。最主要的两个回调方法onScroll()和onFling()方法，分别代表手指的拖拽过程和手指离开
                屏幕后的惯性滑动过程。在这两个过程中根据手值的滑动区域和惯性滑动区域来动态的确定图片的加载区域即可。


























