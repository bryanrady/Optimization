一、Activity
    1.定义
        四大组件之一，是用户交互的界面。一般的来说一个用户交互界面对应一个activity。

    2.生命周期
        Activity从创建到销毁之间有多种状态，每一种状态对应一个生命周期方法。这些回调方法包括：
        onCreate()、onStart()、onResume()、onPause()、onStop()、onDestroy()。

        这些方法都是两两对立的：
            onCreate()和onDestroy()  ---------   创建和销毁
            onStart()和onStop()      ---------   可见与不可见
            onResume()和onPause()    ---------   可编辑和不可编辑

        (1)界面从创建到跳转到界面B，再从界面B返回，两个Activity的生命周期变化？
                A创建到可见过程。
            A：onCreate()->onStart()->onResume();
                A跳转到B，即B创建到可见过程，这时候A失去了焦点，处于不可编辑状态。B可见后，A就不可见了。
            A：onPause();
            B: onCreate()->onStart()->onResume();
            A: onStop();
                从B返回到A的过程。即B失去了焦点，处于不可编辑状态，重新进入到A可见，然后B不可见到销毁
            B：onPause();
            A：onRestart()->onStart()->onResume();
            B：onStop()->onDestroy();

        (2)界面从创建到跳转到界面B(B界面是透明主题的或者是Dialog形式的)，再从界面B返回，两个Activity的生命周期变化？
                 A创建到可见过程。
            A：onCreate()->onStart()->onResume();
                A跳转到B，即B创建到可见过程，这时候A失去了焦点，处于不可编辑状态。B可见后，A就不可见了。
            A：onPause();
            B: onCreate()->onStart()->onResume();
            A: onStop();
                从B返回到A的过程。即B失去了焦点，处于不可编辑状态，重新进入到A可见，然后B不可见到销毁
            B：onPause();
            A：onResume();   因为B是透明的或者是Dialog形式的，说明A还是可见的，所以不会调用onReStart()和onStart()了。
            B：onStop()->onDestroy();

        (3)创建界面A后，点击Home按键，再回到界面A，这是A的生命周期变化？
            创建A
        A：onCreate()->onStart()->onResume();
            点击Home键
        A：onPause->onStop();
            再次回到A
        A：onRestart()->onStart()->onResume();

        (4)两个Activity之间的跳转必定会执行的是哪几个生命周期方法？
            前一个activity的onPause()和后一个Activity的onResume();

        (5)横竖屏切换，Activity的生命周期变化？
           竖屏切横竖：onPause()->onStop()->onDestroy()->onCreate()->onStart()->onRestart()。
           横竖切竖屏：onPause()->onStop()->onDestroy()->onCreate()->onStart()->onRestart()。
           这两次切换都不会回调：onConfigurationChanged()方法。

           有的人说横屏切竖屏会打印两次相同的生命周期方法，但是我的测试是只有一次，具体原因
           没有深究，不知道是否与机型有关。

           如果在AndroidManifest.xml文件中设置该Activity的configChanges="orientation"时：
           竖屏切横竖：onPause()->onStop()->onDestroy()->onCreate()->onStart()->onRestart()。
                有些手机在竖屏切横屏的时候也不会打印生命周期方法，如P30，好像和机械有关。
           横竖切竖屏：什么都不打印。

           设置configChanges属性的目的是为了在切屏时不让Activity进行销毁和重建。
           这两次切换都会回调：onConfigurationChanged()方法。好像只要有orientation这个属性，
           就都会回调onConfigurationChanged()方法。

    3. onSaveInstanceState()和onRestoreInstanceState()会在什么时候回调?
        当系统“未经用户许可”准备让Activity变得失去焦点时()，onSaveInstanceState()会被系统调用，
        因为它必须要提供一个机会让用户能够保存数据(当然保不保存就是你自己的事情了)。如果我们是
        通过返回按钮返回上一个Activity，则这个Activity的 onSaveInstanceState()不会被回调，因为
        这个是用户自己选择的操作，不是系统原因。
        onSaveInstanceState()一般都是在onPause回调之后进行回调。
        以下几种情况的分析都遵循该原则：
        (1)长按Home键，选择运行其他的程序时。
        (2)按下电源按键（关闭屏幕显示）时。
        (3)从Activity A中启动一个新的Activity时。
        (4)屏幕方向切换时，例如从竖屏切换到横屏时。

        至于onRestoreInstanceState()方法，需要注意的是，onSaveInstanceState()和onRestoreInstanceState()
        “不一定”是成对的被调用的。onRestoreInstanceState()被调用的前提是，Activity A“确实”被系统销毁了。
        而如果仅仅是停留在有这种可能性的情况下，则该方法不会被调用，例如，当正在显示Activity A的时候，
        用户按下Home键回到主界面，然后用户紧接着又返回到activity A，这种情况下Activity A一般不会因为内存的
        原因被系统销毁，故Activity A的onRestoreInstanceState方法不会被执行。
        而横竖屏切换的时候Activity是真正的被系统销毁了，所以会调用onRestoreInstanceState()。
        onRestoreInstanceState()一般都是在onResume()回调之前进行回调。

    4. Activity的四种启动模式及应用场景
        (1)standard     标准启动模式(Activity的默认启动模式)
            每启动一个Activity，都会创建一个新的实例，不管栈中是否已经存在这个实例，每次都会创建的实例存放于栈顶。
            返回的时候，将这个Activity对应的实例出栈。

            应用场景：这个好像程序大多数都是默认用这个实例的。

        (2)singleTop    栈顶复用模式
            每启动一个Activity，如果该Activity对应的实例位于栈顶，则不会创建新的实例，直接复用当前Activity对应
            的实例，即不会走该Activity的onCreate()->onStart()，直接走该Activity的onPause()->onNewIntent()->onResume();
            如果该Activity对应的实例没有位于栈顶，则会创建新的实例。

            应用场景：系统推送通知栏。

        (3)singleTask   栈中复用模式
            每启动一个Activity，如果栈中已经存在该Activity对应的实例，则不会创建新的实例，并将它实例上面的Activity
            都出栈，直到该Activity位于栈顶，即不会走该Activity的onCreate()->onResume()；直接回调onIntent(),直接走
            该Activity的onRestart()->onStart()->onResume()；如果栈中不存在该Activity对应的实例，就会创建新的实例存
            放于栈顶。

            应用场景：程序模块逻辑入口，应用的主页面和登录页面(我们肯定不会让我们的主界面和登录页面被多次创建，而且
            在主界面或者登录页面退出应用程序是最好的选择)；
            WebView页面、扫一扫页面、购物页面、确认订单页面、付款页面等。

        (4)singleInstance   单一实例模式
            每启动一个Activity，都会将该Activity存放于单独的一个栈中，并且这个栈中只有该Activity一个实例，下次再启动
            这个Activity的时候，都不会创建新的实例，而是将以前创建的Activity从独立的栈中唤醒。执行流程和已经存在有实
            例的singleTask启动模式差不多，也直接回调onIntent(),直接走该Activity的onRestart()->onStart()->onResume()。

            应用场景：Launcher页面、电话页面、闹钟等系统应用 。


二、Service
    1.定义
        服务是一种可以在后台长时间运行而没有用户界面的应用组件，除非系统必须回收内存资源，否则系统不会停止或销毁服务。
        它是运行在主线程的。

    2.启动服务的两种方式
        startService()：调用者退出后服务仍然存在。只有调用stopService()服务才会退出。
        bindService()：调用者退出后服务也会跟着退出。即不调用unbindService()服务也会自动退出。

    3.Service的生命周期和启动方式有关
        (1)只是用startService()启动服务：
            onCreate()->onStartCommand()->onDestroy()。
        (2)只是用bindService()启动服务：
            onCreate()->onBind()->onUnBind()->onDestroy()。

    4.Service如何与Activity进行通信？
        (1)在Service中添加一个继承自Binder的内部类，并在内部类中添加相应的逻辑方法；然后在Service中的onBind()返回内部类
            Binder的实例；重写onServiceConnected()、onServiceDisconnected()方法时调用逻辑方法。
        (2)通过自定义接口进行交互。
        (3)通过BroadcastReceiver广播方式实现组件间的通信。
        (4)通过信使Messenger。

    5.Service中可以执行耗时操作吗？
        如果没有指定Service所运行的进程，Service和Activity一样都是默认运行在当前应用主线程的，它并不是创建了一个新的进程
        或创建了一个新的线程，它是依赖于应用程序主线程的，所以我们不能在Service中执行耗时操作，否则可能会引起ANR。
        如果我们需要在Service中执行耗时操作：
        (1)通过开启线程方式来执行。
        (2)使用AsyncTask异步任务。
        (3)使用IntentService异步管理服务。

    6.Service的onStartCommand()方法有几种返回值？
        (1)START_STICKY
            "粘性的"。如果Service被kill掉，保留Service的状态为开始状态，但不保留传递的Intent对象。随后系统会尝试重新创建
            Service,由于Service状态为开始状态，所以创建服务后一定会调用onStartCommand(Intent,int,int)方法，如果在此期间没有
            任何启动命令被传递到Service,那么参数 Intent 将为 null。
        (2)START_NOT_STICKY
            非粘性的。使用这个返回值时,如果在执行完 onStartCommand()后,服务被异常 kill 掉,系统不会自动重启该服务。
        (3)START_REDELIVER_INTENT
            重传 Intent。使用这个返回值时,如果在执行完 onStartCommand()后,服务被异常 kill 掉,系统会自动重启该服务,
            并将参数 Intent 的值传入。
        (4)START_STICKY_COMPATIBILITY
            START_STICKY 的兼容版本,但不保证服务被 kill 后一定能重启。

    7.Service 的 onRebind()方法在什么情况下会执行?
        如果在onUnbind()中返回true，onRebind()就会执行，否则不会执行。

    8.能在Service中弹吐司Toast么？
        可以。弹吐司需要的一个重要参数就是context，而Service本身就是Context的子类，所以在Service中弹吐司是没有任何问题的。

    9.一般会在什么情况下用到Service？
        一般长期在后台工作的任务都需要放到Service中去做。比如音乐播放、文件下载、大文件上传、定时关闭应用等功能，如果我们
        将这些功能放到Activity中去做，可能会因为Activity的生命周期导致这些功能不能实现。总的来说就是我们在Activity不能满足
        需求的情况下我们会考虑使用到Service。

    10.Activity如何与Service进行绑定，怎么在Activity中启动对应的Service？
        Activity通过bindService()方法跟Service来进行绑定，当绑定成功的时候Service会将代理对象通过接口回调给conn，这样我们就
        拿到了Service提供的服务代理对象。
        在Activity中可以通过startService()和bindService()启动服务。如果我们想获取Service的代理对象那么只能通过bindService()；
        如果仅仅是为了开启一个后台任务那么可以直接使用startService()。

    11.什么是IntentService？
        IntentService是Service的子类，是一个异步的，会自动停止的服务，很好解决了传统的Service中处理完耗时操作忘记停止并销毁
        Service的问题。

        源码分析：
        看了源码才知道，就是让用户可以在Service中进行的耗时操作而生的。IntentService继承了Service，并且在onCreate()方法中
        根据构造函数传进来的名字通过HandlerThread创建了线程，然后从HandlerThread中拿到当前线程的Looper，创建相应现场的对应
        的Handler。onStart()方法原来在Service中是在onStartCommand()方法中进行调用的，并且是空实现的方法。而在IntentService
        中重写了onStart()方法，并且通过Handler发送了一条带有onStart()方法中所有参数的消息，然后在自定义Handler的handleMessage()
        方法中处理消息，最后都统一由onHandlerIntent来进行处理，然后通过stopSelf停止处理完了的服务。

        还有一点，IntentService最好不要通过bindService来绑定服务，因为IntentService中onBind()是默认返回null，如果你执意要
        bindService() 来启动 IntentService，可能因为你想通过 Binder 或 Messenger 使得 IntentService 和 Activity 可以通信，
        这样那么 onHandleIntent() 不会被回调，相当于在你使用 Service 而不是 IntentService。

    12.IntentService和Service相比有什么优点？
        (1)我们不用在Service中手动开启线程，IntentService内部的onCreate()就已经通过HandlerThread默认开启了线程。
        (2)当操作完成后，我们不用手动的去停止Service。IntentService内部的Handler的handleMessage()方法中，当onHandleIntent()
            处理完成后，IntentService会调用stopSelf()自动停止服务。

    13.如何提高Service的优先级？(也就是让Service存活率变高)
        (1)在AndroidManifest.xml文件中对于intent-filter可以通过android:priority = “1000”这个属性设置最高优先级，1000是最高值，
            如果数字越小则优先级越低，同时实用于广播。
        (2)在onStartCommand() 里面调用 startForeground()方法把Service提升为前台进程级别，然后再onDestroy()里面要记得调用
            stopForeground()方法。
        (3)在onStartCommand方法，手动返回START_STICKY。当服务被异常kill掉，系统会尝试重启服务。
        (4)在Service的onDestroy()方法里发广播重启Service。
        (5)监听系统广播判断Service状态。比如手机重启、界面唤醒、应用状态改变等等监听并捕获到，然后判断我们的Service是否还存活。
        (6)Application加上Persistent属性。

